# 算法复杂度 #

## 空间复杂度 ##
算法的空间复杂度(SpaceComplexity)S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。一个算法在计算机存储器上所占用的存储空间，包括**存储算法本身所占用的存储空间**，算法的**输入输出数据所占用的存储空间** 和算法在**运行过程中临时占用的存储空间**这三个方面。

算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。

存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。

算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“就地"进行的，是节省存储的算法，有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况。

分析一个算法所占用的存储空间要从各方面综合考虑。如对于递归算法来说，一般都比较简短，算法本身所占用的存储空间较少，但运行时需要一个附加堆栈，从而占用较多的临时工作单元；若写成非递归算法，一般可能比较长，算法本身占用的存储空间较多，但运行时将可能需要较少的存储单元。


## 时间复杂度 ##
时间复杂度是总运算次数表达式中受n的变化影响最大的那一项

一个算法中的语句执行次数称为语句频度或时间频度。记为t(n)。

一般情况下，算法的基本操作重复执行的次数是模块n的某一个函数f（n），因此，算法的时间复杂度记做：T（n）=O（f（n））。随着模块n的增大，算法执行的时间的增长率和f（n）的增长率成正比，所以f（n）越小，算法的时间复杂度越低，算法的效率越高。

在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，再找出T（n）的同数量级（它的同数量级有以下：1，Log2n ，n ，nLog2n ，n的平方，n的三次方，2的n次方，n！），找出后，f（n）=该数量级，若T(n)/f(n)求极限可得到一常数c，则时间复杂度T（n）=O（f（n））。

### 1、常见的时间复杂度 ###

- O(n)，O(n^2)， 立方阶O(n^3),...， k次方阶O(n^k) 为多项式阶时间复杂度，分别称为一阶时间复杂度，二阶时间复杂度。。。。

- O(2^n)，指数阶时间复杂度，该种不实用

- 对数阶O(log2n),   线性对数阶O(nlog2n)，除了常数阶以外，该种效率最高

### 2、时间复杂性案例 ###


**如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)，它是n的某一函数
 T(n)称为这一算法的“时间复杂性”。**

- **O(1)**
<pre>
Temp=i;i=j;j=temp;
</pre>                    

以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。

- **O(n^2)**
交换i和j的内容
<pre>
 sum=0；             （一次）
 for(i=1;i<=n;i++)   （n次）
    for(j=1;j<=n;j++)（n^2次）
     sum++；       （n^2次）
</pre>
解：T(n)=2n^2+n+1 =O(n^2)

- **O(n)**

<pre>
a=0;
    b=1;            ①
    for
 (i=1;i<=n;i++)    ②
    {  
       s=a+b;　　　　③
       b=a;　　　　　④  
       a=s;　　　　　⑤
    }
</pre>
解：语句1的频度：2,        
   语句2的频度： n,        
   语句3的频度： n-1,        
   语句4的频度：n-1,    
   语句5的频度：n-1,                                  
   T(n)=2+n+3(n-1)=4n-1=O(n).

- **O(log2n)**

<pre>
i=1;       ①
while (i<=n)
   i=i*2; ②
</pre>
解： 语句1的频度是1,  
  设语句2的频度是f(n), 则：2^f(n)<=n;f(n)<=log2n    
  取最大值f(n)=log2n,
  T(n)=O(log2n )

- **O(n^3)**

<pre>
for(i=0;i<\n;i++)
{  
   for(j=0;j<\i;j++)  
   {
      for(k=0;k<\j;k++)
         x=x+2;  
   }
}
</pre>
解：当i=m,j=k的时候,内层循环的次数为k当i=m时, j 可以取 0,1,...,m-1 , 所以这里最内循环共进行了0+1+...+m-1=(m-1)m/2次所以,i从0取到n, 则循环共进行了: 0+(1-1)*1/2+...+(n-1)n/2=n(n+1)(n-1)/6所以时间复杂度为O(n^3).

## 时间与空间复杂度比较 ##

对于一个算法，其时间复杂度和空间复杂度往往是相互影响的。当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，当追求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。另外，算法的所有性能之间都存在着或多或少的相互影响。因此，当设计一个算法(特别是大型算法)时，要综合考虑算法的各项性能，算法的使用频率，算法处理的数据量的大小，算法描述语言的特性，算法运行的机器系统环境等各方面因素，才能够设计出比较好的算法。算法的时间复杂度和空间复杂度合称为算法的复杂度。

## 参考资料 ##

- [空间复杂度(Space Complexity)和时间复杂度的计算](http://www.jianshu.com/p/53299390510e#)

- [如何计算时间复杂度](http://blog.csdn.net/firefly_2002/article/details/8008987)