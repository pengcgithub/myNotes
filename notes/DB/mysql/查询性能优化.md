# 查询性能优化

引擎

目前广泛使用的是MyISAM和InnoDB两种引擎：

MyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特点是：

- 不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁
- 不支持事务
- 不支持外键
- 不支持崩溃后的安全恢复
- 在表有读取查询的同时，支持往表中插入新纪录
- 支持BLOB和TEXT的前500个字符索引，支持全文索引
- 支持延迟更新索引，极大提升写入性能
- 对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用

InnoDB在MySQL 5.5后成为默认索引，它的特点是：

- 支持行锁，采用MVCC来支持高并发
- 支持事务
- 支持外键
- 支持崩溃后的安全恢复
- 不支持全文索引

总体来讲，MyISAM适合SELECT密集型的表，而InnoDB适合INSERT和UPDATE密集型的表

- 硬件优化

- 应用访问优化

减少数据访问（减少磁盘访问）

返回更少数据（减少网络传输或磁盘访问）

较少交互次数（减少网络传输）

- 参数优化

- sql优化

	- schema优化
	- 索引
	- 索引失效的sql操作
	- 分析执行计划

## sql优化

### 参数优化

配置文件的位置一般在/etc/my.cnf或则/etc/mysql/my.cnf。

InnoDB在大多数情况下如果要运行的很好，配置大小合适的缓冲池（Buffer Pool）和日志文件（Log File）是必须的。

运行`SHOW GLOBAL STATUS`命令，查看服务器状态变量。

基础配置
<pre>
[mysqld]
# GENERAL
datadir = /var/lib/mysql
socket = /var/lib/mysql/mysql.sock
pid_file = /var/lib/mysql/mysql.pid
user = mysql
port = 3306
default_storage_engine = InnoDB
# INNODB
innodb_buffer_pool_size = value
innodb_log_file_size = value
innodb_file_per_table = 1
innodb_flush_method = 0_DIRECT
# MYISAM
key_buffer_size = value
# LOGGING
log_error = /var/lib/mysql/mysql-error.log
slow_query_log = /var/lib/mysql/mysql-slow.log
# OTHER
tmp_table_size = 32M
max_heap_table_size = 32M
query_cache_type = 0
query_cache_size = 0
max_connections = value
thread_cache = value
table_cache = value
open_files_limit = 65535
[client]
socket = /var/lib/mysql/mysql.sock
port = 3306
</pre>

每个连接需要的内存

为操作系统保留内存

至少应该为操作系统保留1GB-2GB的内存，如果机器内存更多就再多预留一点。我们建议2GB或总内存的5%作为基准，以较大者为准。如果服务器只运行MYSQL，所有不需要为操作系统以及查询处理保留的内存都可以用作MYSQL缓存。

InnoDB缓冲池(Buffer Pool)

如果大部分都是InnoDB表，InnoDB缓冲池或许比其他任何东西都需要内存。InnoDB缓冲池并不仅仅缓存索引，它还会缓存行的数据、自适应hash索引、插入缓冲、锁，以及其他内部数据结构。InnoDB还使用缓冲池来来帮助延迟写入，这样就能合并多个写入操作，然后一起顺序的写回。

线程缓存


innodb_buffer_pool_instances

### 索引

索引（在MYSQL中也叫做“键（key）”）是存储引擎快速找到记录的一种数据结构。

> 索引的类型

- B_Tree索引

- 哈希索引

在MYSQL中，只有Memory引擎显式支持哈希索引。

- 全文索引

> 索引的优点

- 索引大大减少了服务器需要扫描的数据量
- 索引可以帮助服务器避免排序和临时表
- 索引可以将随机I/O变成顺序I/O

> 高性能的索引策略

- 独立的列

不是函数和表达式

- 多列索引

当服务器对多个索引做相交操作时（通常有多个AND条件），意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。

- 选择合适的索引列顺序

- 覆盖索引

如果一个索引包含（或则说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。

- 使用索引扫描来做排序

只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样时，MYSQL才能够使用索引对结果做排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。ORDER BY子句和查找性查询的限制是一样的：需要满足索引的最左前缀的要求；否则，MYSQL都需要执行排序操作，而无法利用索引排序。

有一种情况下ORDER BY子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。如果WHERE子句或则JOIN字句中对这些列指定了常量，就可以“弥补”索引的不足。

(rental_date，inventory_id，customer_id)
FROM rental WHERE rental_date = '2018-12-31' ORDER BY inventory_id, customer_id


- 冗余和重复索引

如果创建了索引（A,B），再创建索引（A）就是冗余索引。

- 未使用的索引

- 优化排序

延迟关联

<pre>
SELECT * FROM S_CUSTOMER
INNER JOIN (
	SELECT id FROM S_CUSTOMER ORDER BY MODIFIED_TIME LIMIT 100000, 10
) AS cus USING (ID);
</pre>